# Oracle Database Changes in CI/CD Workflow

## Introduction

We have a web application developed in Python, running as a micro-service in a Docker container, on OKE cluster using OCI. This application connects to an Oracle Database, and we have seen how CI/CD principles and concepts can be applied to develop this application. We will apply same principles to Oracle Database changes, while altering existing objects, or create new ones, at the same time with application development. Furthermore, we track all database changes, merge them with the code master branch, and make them available to all developers.

There are two methods to capture and track database changes:

1. State based (automated) — Script auto generated by a state comparator containing differences between states (deltas). It still requires a manual step to review the generated change script (highly recommended).

2. Migration based (manual) — Change script created by developer containing changes to apply to the database, in a certain order. The quality of script depends on SQL skills of the application developer.

The tool we use to track, version, and deploy database schema changes is [Liquibase](https://www.liquibase.org/). Liquibase supports a broad range of databases, including Oracle Database. We will use migration based method, because Liquibase is not great at capturing existing changes in an Oracle Database.

## Step 1: Liquibase Basic Practice

Before using Liquibase in development, it is a good idea to test it and see how it works. Create a test folder.

````
mkdir liquibase_test

cd liquibase_test
````

Create a test user in your database.

````
sqlplus sys/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] as sysdba

drop user cicd_user cascade;

CREATE USER cicd_user IDENTIFIED BY OraPTS#2020_ DEFAULT TABLESPACE users TEMPORARY TABLESPACE temp;
GRANT connect, resource to cicd_user;
GRANT UNLIMITED TABLESPACE TO cicd_user;
````

Login as test user.

````
conn cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name]
````

Create some objects in test user schema: a table, a trigger, a sequence, and a function. Run these commands one by one.

````
CREATE TABLE feedback (
  id       NUMBER,
  details  VARCHAR2(255),
  received DATE,
  CONSTRAINT feedback_pk PRIMARY KEY (id)
);

CREATE OR REPLACE TRIGGER feedback_bi
    before insert on feedback
    for each row
begin
    :new.received := sysdate;
end;
/
ALTER TRIGGER feedback_bi ENABLE
/

CREATE SEQUENCE feedback_seq;

INSERT INTO feedback (id, details) VALUES (feedback_seq.NEXTVAL, 'Feedback for exercise number ' || feedback_seq.CURRVAL);

COMMIT;

CREATE OR REPLACE FUNCTION today_feedback_count RETURN NUMBER AS
  l_count  NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO   l_count
  FROM   feedback
  WHERE  received >= trunc(sysdate);

  RETURN l_count;
END;
/
````

Exit SQL*Plus.

````
exit;
````

Create a properties file to store your database connection information.

````
gedit cicd-user.properties
````

Write the following lines, and save the file before closing.

````
driver : oracle.jdbc.OracleDriver
classpath : /usr/lib/oracle/19.6/client64/lib/ojdbc8.jar
url : jdbc:oracle:thin:@//[DB System Public IP]/[PDB_service_name]
username : cicd_user
password : OraPTS#2020_
````

This file contains:

- driver - driver class name
- classpath - path for your database driver
- url - Oracle JDBC connect string
- username - database user
- password - database password

>**Note** : The path for your database driver may be different on deployment environment. In our case, on the container where we deploy our Python microservice, we installed Oracle Instant Client 19.6, and the classpath property is /usr/lib/oracle/19.6/client64/lib/ojdbc8.jar. This is important, as the code we create on the development environment should work on deployment with no changes. This rule applies for all other important packages, e.g. Java. We will not run Liquibase on the Docker container where our microservice is deployed, as we connect to the same database both development and production (deployment) applications.

## Step 2: Generate Initial Change-Log

Liquibase can generate a change-log based on an existing schema, capturing existing objects. Run the following command to generate the initial change-log.

````
liquibase --defaultsFile="cicd-user.properties" --changeLogFile="initial-changelog.oracle.sql" generateChangeLog
````

Open the generated initial change-log file.

````
gedit initial-changelog.oracle.sql
````

This is the content.

````
--liquibase formatted sql

--changeset oracle:1588064126450-1
CREATE TABLE FEEDBACK (ID NUMBER NOT NULL, DETAILS VARCHAR2(255 BYTE), RECEIVED date, CONSTRAINT FEEDBACK_PK PRIMARY KEY (ID));

--changeset oracle:1588064126450-2
CREATE SEQUENCE FEEDBACK_SEQ START WITH 21 MAXVALUE 9999999999999999999999999999;
````

Generated change log has only the table and the sequence. The trigger and the function are missing. In conclusion, it is recommended to start from an existing schema and start tracking all changes with Liquibase, and avoid relying on an initial change-log generated by Liquibase to initialize our environment from a master branch. There are better methods to create a database environment from a master branch, like Pluggable Database (PDB) cloning.

## Step 3: Use Generic Properties File

We can avoid using defaultsFile option for every execution creating a generic properties file present in our current location, called liquibase.properties.

````
gedit liquibase.properties
````

Contents of the file are the same, with an extra line, that defines a master change-log file. This master change-log contains a list of change-logs, in a specific order, and grouped in change-sets.

````
driver : oracle.jdbc.OracleDriver
classpath : /usr/lib/oracle/19.6/client64/lib/ojdbc8.jar
url : jdbc:oracle:thin:@//[DB System Public IP]/[PDB_service_name]
username : cicd_user
password : OraPTS#2020_
changeLogFile : cicd-master.xml
````

A developer needs to write all database changes in change-logs, like the following one:

````
gedit changelog_001.sql
````

There are multiple formats available. We will use SQL format, it is easy to read and it contains the exact DDL.

````
--liquibase formatted sql
--changeset valentin:1
--comment create workshops table
create table workshops (
    id number generated always as identity,
    name varchar2(80),
    active varchar2(1) default 'N',
    constraint workshops_pk primary key (id)
);
 
--rollback drop table workshops purge;
````

First line is the format. Second one specifies the author, and the order of execution. In the third line, you can add a comment, and the last line defines the rollback command. If you want to apply just an individual change-log, execute this command:

````
liquibase --changeLogFile="changelog_001.sql" update
````

It overrides changeLogFile parameter specified in liquibase.properties.

## Step 4: Query Database Change-Log Table

Create the following script to verify the results.

````
gedit query_log.sql
````

We just need to query a standard table created by Liquibase, named DATABASECHANGELOG.

````
set linesize 120
column AUTHOR format a10
column FILENAME format a20
column TAG format a15
column COMMENTS format a50

select AUTHOR, FILENAME, ORDEREXECUTED, TAG, COMMENTS from DATABASECHANGELOG order by 3;

exit;
````

Run the verification script.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
````

Just one change-log recorded. Let's roll back this change-log now. The command rollbackCount <value> rolls back the last <value> change sets.

````
liquibase --changeLogFile="changelog_001.sql" rollbackCount 1
````

Verify the change-log.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

no rows selected
````

Create a new changelog for a function.

````
gedit changelog_002.sql
````

````
--liquibase formatted sql
--changeset leonard:2
--comment create active workshops count function
CREATE OR REPLACE FUNCTION active_workshops_count RETURN NUMBER AS
  l_count  NUMBER;
BEGIN
  SELECT COUNT(*)
  INTO   l_count
  FROM   workshops
  WHERE  active = 'Y';

  RETURN l_count;
END;
/

--rollback drop function active_workshops_count;
````

Create another change-log with a new table.

````
gedit changelog_003.sql
````

````
--liquibase formatted sql
--changeset valentin:3
--comment create sessions table
create table sessions (
    id number generated always as identity,
    workshop_id number,
    start_date date,
    constraint sessions_pk primary key (id)
); 

--rollback drop table sessions purge;
````

## Step 5: Use Master Change-Log File

We have 3 change-logs for 3 new database objects. These 3 change-logs can be consolidated in the master change-log file. Master change-log can be used also to automate changes in a certain order, making sure the database can be rolled back at any state.

````
gedit cicd-master.xml
````

All 3 change-logs are part of the same change-set, we call **version_1.1**. Change-sets may have a different author than the change-logs in them.

````
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
    <include file="changelog_001.sql"/>
    <include file="changelog_002.sql"/>
    <include file="changelog_003.sql"/>
    <changeSet author="student" id="test_objects">
        <tagDatabase tag="version_1.1"/>
    </changeSet>
</databaseChangeLog>
````

We can specify change-logs one by one, or use a path to include them all. We will call them individually so you can understand the order, because when using a path, the order is defined by the name of the files.

````
    <includeAll path="/git/my_project/changelogs"/>
````

Apply all 3 changes using a simple command, as there is no need to specify the properties file nor the specific change-logs. 

````
liquibase update
````

Verify changes are applied and recored in our database.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
leonard    changelog_002.sql		    2		      create active workshops count function
valentin   changelog_003.sql		    3		      create sessions table
student    cicd-master.xml		    4 version_1.1
````

When we use rollbackCount command, this includes also the definition of the change-set. 

````
liquibase rollbackCount 1
````

Now we have only the change-logs applied and recorded, but not the change-set.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
leonard    changelog_002.sql		    2		      create active workshops count function
valentin   changelog_003.sql		    3		      create sessions table
````

Let's rollback last two changes.

````
liquibase rollbackCount 2
````

Check the results.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
````

One change-log left. Roll it back to clean the schema.

````
liquibase rollbackCount 1
````

Group the change-logs in two different change-sets.

````
gedit cicd-master.xml
````

````
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
    <include file="changelog_001.sql"/>
    <changeSet author="student" id="first_objects">
        <tagDatabase tag="version_1.0"/>
    </changeSet>
    <include file="changelog_002.sql"/>
    <include file="changelog_003.sql"/>
    <changeSet author="student" id="more_objects">
        <tagDatabase tag="version_1.1"/>
    </changeSet>
</databaseChangeLog>
````

Apply the master change-log.

````
liquibase update
````

Verify the changes on the database.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
student    cicd-master.xml		    2 version_1.0
leonard    changelog_002.sql		    3		      create active workshops count function
valentin   changelog_003.sql		    4		      create sessions table
student    cicd-master.xml		    5 version_1.1
````

Change-sets allow us to roll back the database to the state it was in when the change-set with that tag was applied.

````
liquibase rollback version_1.0
````

Check the results.

````
sqlplus cicd_user/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

AUTHOR	   FILENAME		ORDEREXECUTED TAG	      COMMENTS
---------- -------------------- ------------- --------------- --------------------------------------------------
valentin   changelog_001.sql		    1		      create workshops table
````

In this case, only one change-log remains, as this existed when change-set with tag version_1.0 was applied.

## Step 6: Use Liquibase on Development for CI/CD

Now we know how Liquibase works, and we can go back to our Python micro-service application. We can make some changes to the database, while tracking and recording them on the master branch using Liquibase.

````
cd ~/orcl-ws-cicd
````

It is a good practice to group change-logs in folders.

````
mkdir chlg
````

Create the first change-log for a new table.

````
gedit chlg/changelog_001.sql
````

````
--liquibase formatted sql
--changeset developer:1
--comment create bonuses table
CREATE TABLE bonuses (
    employee_id NUMBER(6,0) NOT NULL,
    bonus NUMBER(8,2) DEFAULT 100
);

INSERT INTO bonuses(employee_id) (
    SELECT employee_id
    FROM employees
    WHERE salary < 10000
);
 
--rollback drop table bonuses;
````

Some changes may include PL/SQL scripts. It is a good practice to keep your DDL changes and PL/SQL code separated.

````
mkdir plsql
````

When a change-log does not create a new object, or a roll-back statement cannot be specified, it is good to have a null statement for rollback for Liquibase to clear the records correctly in the DATABASECHANGELOG table.

````
gedit plsql/script_001.sql
````

````
--liquibase formatted sql
--changeset developer:2
--comment update bonuses table
MERGE INTO bonuses b USING employees e
    ON ( b.employee_id = e.employee_id) 
    WHEN MATCHED THEN
        UPDATE SET b.bonus = e.salary * .05;

MERGE INTO bonuses B
  USING (SELECT employee_id, salary, department_id FROM employees
         WHERE department_id = 80) E
  ON (B.employee_id = E.employee_id)
  WHEN MATCHED THEN UPDATE SET B.bonus = B.bonus + E.salary * .01
  WHEN NOT MATCHED THEN INSERT (B.employee_id, B.bonus)
    VALUES (E.employee_id, E.salary * 0.1);

--rollback select null from dual;
````

Create a new change-log for a trigger.

````
gedit chlg/changelog_002.sql
````

For the rollback statement in this case, we can choose to disable the trigger, or drop it.

````
--liquibase formatted sql
--changeset architect:3
--comment changes on employees only in business hours
CREATE OR REPLACE TRIGGER  trg_employees_changes
before update or insert or delete
on employees
for each row
begin
   if  to_char(sysdate,'hh24') < 6 or to_char(sysdate,'hh24') > 10 then
         raise_application_error(-20234,'No changes allowed before 9 AM and after 6 PM');
   end if;
end;
/
ALTER TRIGGER trg_employees_changes ENABLE
/
 
--rollback drop trigger trg_employees_changes;
````

It is also a good practice to return errors so others can understand the business logic behind the new database objects. In this example we use the function **raise_application_error(error_number, message)**. The error_number is a negative integer with the range from -20999 to -20000. The message is a character string that represents the error message, with a length up to 2048 bytes.

Add another change-log for a second trigger.

````
gedit chlg/changelog_003.sql
````

````
--liquibase formatted sql
--changeset architect:4
--comment cannot decrease employee salary
CREATE OR REPLACE TRIGGER  trg_employees_relegation
before update
on employees
for each row
begin
   if  :old.salary > :new.salary then
         raise_application_error(-20123,'Salary can not be decreased');
   end if;
end;
/
ALTER TRIGGER trg_employees_relegation ENABLE
/
 
--rollback drop trigger trg_employees_relegation;
````

One more change-log for a function.

````
gedit chlg/changelog_004.sql
````

````
--liquibase formatted sql
--changeset developer:5
--comment create function to calculate experience
CREATE OR REPLACE FUNCTION experience(employee_id NUMBER)
  RETURN VARCHAR2
IS
  l_years NUMBER;
  l_months NUMBER;
BEGIN
  select trunc(months_between(sysdate,HIRE_DATE) / 12) into l_years,
         trunc(months_between(sysdate,HIRE_DATE) -
            (trunc(months_between(sysdate,HIRE_DATE) / 12) * 12)) into l_months

  RETURN ('Employee ID ' || employee_id || ' has ' || l_years || ' years and ' || l_months || ' months of experience.' );
END experience;
/

--rollback drop function experience;
````

Now we create the generic Liquibase properties file.

````
gedit liquibase.properties
````

````
driver : oracle.jdbc.OracleDriver
classpath : /usr/lib/oracle/19.6/client64/lib/ojdbc8.jar
url : jdbc:oracle:thin:@//[DB System Public IP]/[PDB_service_name]
username : hr
password : OraPTS#2020_
changeLogFile : hr-master.xml
````

Create the change-log master file.

````
gedit hr-master.xml
````

This change-log master has 4 change-logs, 1 PL/SQL script, organized in 3 change-sets.

````
<?xml version="1.0" encoding="UTF-8"?>
<databaseChangeLog
  xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog
                      http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.8.xsd">
    <include file="./chlg/changelog_001.sql" relativeToChangelogFile="true"/>
    <include file="./plsql/script_001.sql" relativeToChangelogFile="true"/>
    <changeSet author="developer" id="bonuses_table">
        <tagDatabase tag="version_1.3"/>
    </changeSet>
    <include file="./chlg/changelog_002.sql" relativeToChangelogFile="true"/>
    <include file="./chlg/changelog_003.sql" relativeToChangelogFile="true"/>
    <changeSet author="architect" id="security_triggers">
        <tagDatabase tag="version_1.4"/>
    </changeSet>
    <include file="./chlg/changelog_004.sql" relativeToChangelogFile="true"/>
    <changeSet author="developer" id="experience_function">
        <tagDatabase tag="version_1.5"/>
    </changeSet>

</databaseChangeLog>
````

Create a script to verify the results.

````
gedit query_log.sql
````

This script will return schema objects, and database change-logs applied.

````
set linesize 120
column OBJECT_NAME format a30

select OBJECT_NAME, OBJECT_TYPE from USER_OBJECTS where CREATED >= sysdate - (10/1440) order by 1,2;

column AUTHOR format a10
column FILENAME format a22
column TAG format a15
column COMMENTS format a50

select AUTHOR, FILENAME, ORDEREXECUTED, TAG, COMMENTS from DATABASECHANGELOG order by 3;

exit;
````

## Step 7: Merge Database Changes

Now we can apply all the changes to our database.

````
liquibase update
````

Once finished, check the results.

````
sqlplus hr/OraPTS#2020_@//[DB System Public IP]/[PDB_service_name] @query_log

OBJECT_NAME		       OBJECT_TYPE
------------------------------ -----------------------
BONUSES 		       TABLE
DATABASECHANGELOG	       TABLE
DATABASECHANGELOGLOCK	       TABLE
EXPERIENCE		       FUNCTION
PK_DATABASECHANGELOGLOCK       INDEX
TRG_EMPLOYEES_CHANGES	       TRIGGER
TRG_EMPLOYEES_RELEGATION       TRIGGER

7 rows selected.


AUTHOR	   FILENAME		  ORDEREXECUTED TAG		COMMENTS
---------- ---------------------- ------------- --------------- --------------------------------------------------
developer  chlg/changelog_001.sql	      1 		create bonuses table
developer  plsql/script_001.sql 	      2 		update bonuses table
developer  hr-master.xml		      3 version_1.3
architect  chlg/changelog_002.sql	      4 		changes on employees only in business hours
architect  chlg/changelog_003.sql	      5 		cannot decrease employee salary
architect  hr-master.xml		      6 version_1.4
developer  chlg/changelog_004.sql	      7 		create function to calculate experience
developer  hr-master.xml		      8 version_1.5

8 rows selected.
````

Commit and push all changes to the master branch on code repository.

````
git add chlg/*
git add plsql/*
git add liquibase.properties
git add hr-master.xml
git add query_log.sql
git commit -a -m "Add database CI/CD config and change-logs"
git push
````

With these files on the repository, all developers will know exactly what changes have been applied to the database, and how to roll back any of these changes. Master change-log file will be used by all to merge their change-logs, and group them in change-sets that will be deployed on production at the end of the sprint.

## Acknowledgements

- **Author** - Valentin Leonard Tabacaru
- **Last Updated By/Date** - Valentin Leonard Tabacaru, Principal Product Manager, DB Product Management, May 2020

See an issue? Please open up a request [here](https://github.com/oracle/learning-library/issues). Please include the workshop name and lab in your request.

